import numpy as np
import matplotlib.pyplot as plt


"""
Определяем область интегрирования (у нас — область между двумя спиралями).

Генерируем случайные точки внутри "прямоугольника", покрывающего всю область.

Выбираем точки, которые реально лежат внутри области (маска mask).

Вычисляем функцию f(x,y) для этих точек.

Берём среднее значение функции на точках внутри области.

Умножаем на площадь области, чтобы получить приближённое значение интеграла:
"""

a1, b1 = 0, 1  # Внутренняя спираль: r_in(θ) = a1 + b1*θ
a2, b2 = 0, 1  # Внешняя спираль: r_out(θ) = a2 + b2*θ + 2π
num_turns = 3  # Количество витков спирали
theta_max = 2 * np.pi * num_turns  # Максимальный угол в радианах (3 полных витка)


def r_in(theta):
    """
    Радиус внутренней спирали Архимеда.
    """
    return a1 + b1 * theta

def r_out(theta):
    """
    Радиус внешней спирали Архимеда с добавленным смещением 2π.
    """
    return a2 + b2 * theta + 2 * np.pi


def monte_carlo_area_and_integral(N):
    """
    Метод Монте-Карло для вычисления площади и интеграла функции
    z = x^2 + y^3 по области между внутренней и внешней спиралями Архимеда.
    """

    # --------------------------
    # 1. Генерация случайных точек
    # --------------------------
    # Случайные углы θ равномерно распределены на [0, θ_max]
    theta = np.random.uniform(0, theta_max, N)

    # Максимальный радиус внешней спирали для генерации точек
    r_max_val = np.max(r_out(np.linspace(0, theta_max, 1000)))

    # Случайные радиусы r равномерно на [0, r_max_val]
    # Это создаёт "полярный прямоугольник" в координатах (r, θ), из которого мы потом выбираем точки внутри области
    r = np.random.uniform(0, r_max_val, N)

    # --------------------------
    # 2. Маска точек внутри области между спиралями
    # --------------------------
    # Каждая точка проверяется: r_in(θ) <= r <= r_out(θ)
    # Только эти точки учитываются при расчёте площади и интеграла
    mask = (r >= r_in(theta)) & (r <= r_out(theta))

    # --------------------------
    # 3. Перевод в декартовы координаты для визуализации и функции
    # --------------------------
    x = r * np.cos(theta)
    y = r * np.sin(theta)

    # --------------------------
    # 4. Вычисление площади методом Монте-Карло
    # --------------------------
    # Площадь всего "полярного прямоугольника":
    # В полярных координатах элемент площади: dA = r dr dθ
    # Интеграл по r от 0 до r_max: ∫0^r_max r dr = 0.5 * r_max^2
    # Интеграл по θ от 0 до θ_max: ∫0^θ_max dθ = θ_max
    # Следовательно, площадь всего прямоугольника = 0.5 * r_max^2 * θ_max
    area_total = 0.5 * r_max_val**2 * theta_max

    # Площадь области = площадь прямоугольника * доля точек внутри области
    area = area_total * np.sum(mask) / N

    # --------------------------
    # 5. Вычисление интеграла функции z = x^2 + y^3
    # --------------------------
    z = x**2 + y**3
    # Берём среднее значение функции на точках внутри области и умножаем на площадь
    integral = area * np.mean(z[mask])

    return area, integral, x, y, mask


N_values = [1000, 5000, 10000, 50000, 100000]
results = []

plt.figure(figsize=(15, 10))

for i, N in enumerate(N_values, 1):
    area, integral, x, y, mask = monte_carlo_area_and_integral(N)
    results.append((N, area, integral))

    # Визуализация точек внутри области
    plt.subplot(3, 2, i)
    plt.scatter(x[mask], y[mask], color='blue', s=1, label='точки внутри области')
    plt.title(f"N={N}\nПлощадь≈{area:.2f}, Интеграл≈{integral:.2f}")
    plt.axis('equal')
    plt.xlabel("x")
    plt.ylabel("y")
    plt.legend(markerscale=5)

plt.tight_layout()
plt.show()


print("N\tПлощадь\tИнтеграл")
for r in results:
    print(f"{r[0]}\t{r[1]:.6f}\t{r[2]:.6f}")

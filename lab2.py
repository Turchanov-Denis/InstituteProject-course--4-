import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp


# =====================================================
# 1. Бифуркационная диаграмма для параметра p
# =====================================================

def cubic_roots(p):
    """
    Возвращает корни кубического уравнения
        y^3 + 3y^2 + (1+p)y + (p-1) = 0.

    np.roots вычисляет собственные значения матрицы-компаньона,
    то есть фактически решает характеристическое уравнение.
    Это стандартный численный способ находить корни полиномов.
    """
    coeffs = [1, 3, 1 + p, p - 1]
    return np.roots(coeffs)


# Диапазон параметра p
P = np.linspace(-2, 4, 400)

# Для каждого p собираем только действительные корни
roots_real = []
for pv in P:
    r = cubic_roots(pv)
    roots_real.append([root.real for root in r if np.isreal(root)])

plt.figure(figsize=(6, 4))

# Строим диаграмму: p на оси X, действительные корни на оси Y
for i, pv in enumerate(P):
    for r in roots_real[i]:
        plt.scatter(pv, r, color='blue', s=5)

# Отмечаем значение параметра, при котором происходит перестройка корней
plt.axvline(2, color='red', linestyle='--', label='точка бифуркации p* = 2')
plt.axhline(-1, color='green', linestyle='--', label='y* = -1')

plt.title("Бифуркационная диаграмма")
plt.xlabel("p")
plt.ylabel("y*")
plt.grid(True)
plt.legend()
plt.show()

# =====================================================
# 2. Фазовые траектории 3D-системы
# =====================================================

a = -1


def F(X):
    """
    Правая часть системы ОДУ:
        x' = a*x + y^2 + z^2
        y' = a*y + x^2 + z^2
        z' = a*z + x^2 + y^2

    На входе — вектор X = (x, y, z),
    на выходе — вектор производных.
    """
    x, y, z = X
    return [a * x + y ** 2 + z ** 2,
            a * y + x ** 2 + z ** 2,
            a * z + x ** 2 + y ** 2]


fig = plt.figure(figsize=(6, 6))
ax = fig.add_subplot(111, projection='3d')

# Набор стартовых условий
initial_conditions = [
    (0.2, 0.3, 0.1),
    (1, 0.2, 0.1),
    (-0.5, -0.3, -0.2)
]

for X0 in initial_conditions:
    """
    solve_ivp строит численное решение системы ОДУ.
    Мы используем метод Рунге–Кутты 5-го порядка (по умолчанию — 'RK45').

    ВАЖНО: как строится траектория
    --------------------------------
    - На каждом шаге интегратор оценивает локальную ошибку,
      адаптивно подбирая длину шага.
    - Параметр max_step=0.01 ограничивает максимальный шаг интегрования,
      чтобы траектория не стала грубой.
    - На выходе sol.y — массив формы (3, N),
      где каждая строка — компонентa (x(t), y(t), z(t)),
      а sol.t — массив временных точек t.
    - Траектория в фазовом пространстве — это просто параметризованная
      кривая   t → (x(t), y(t), z(t)).
    """
    sol = solve_ivp(lambda t, X: F(X),
                    [0, 10],  # интервал интегрирования по времени
                    X0,  # начальная точка
                    max_step=0.01)  # ограничение шага

    # Рисуем фазовую траекторию в пространстве (x, y, z)
    ax.plot(sol.y[0], sol.y[1], sol.y[2])

# Отмечаем особые точки (стационарные решения)
special_points = [(0, 0, 0), (0.5, 0.5, 0.5)]
for pt in special_points:
    ax.scatter(*pt, s=50, label=f'Особая точка {pt}')

ax.set_title("Фазовые траектории 3D-системы")
ax.legend()
plt.show()


# =====================================================
# 3. Дискретная динамическая система
# =====================================================

def iterate(x0, N=30, limit=100):
    """
    Строим траекторию дискретной системы:
        x_{n+1} = -x_n + x_n^2.

    - Начинаем с X[0] = x0.
    - На каждом шаге вычисляем x_next по формуле.
    - Если значение растёт слишком сильно, прекращаем вычисления,
      чтобы избежать переполнения.
    """
    X = [x0]
    for _ in range(N):
        x_next = -X[-1] + X[-1] ** 2
        if abs(x_next) > limit:
            break
        X.append(x_next)
    return X

plt.figure(figsize=(6, 5))

for x0 in [-1, 3]:
    X = iterate(x0)
    plt.plot(X, label=f"x0={x0}")

plt.title("Итерации x_{n+1} = -x_n + x_n^2")
plt.xlabel("n")
plt.ylabel("x_n")
plt.grid(True)
plt.legend()
plt.show()
